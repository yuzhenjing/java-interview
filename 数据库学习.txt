如何设计一个关系型数据库

设计以及模块划分
RDBMS 
存储文件 文件系统
程序实例  用逻辑结构映射出物理结构
存储管理  减少IO  数据库吧逻辑存储单位划分为块或者页
应该还有缓存机制 查询出的数据块 放到缓存里  根据一旦某行数据被访问了 他周围的数据极大可能的被访问
操作指令 对外使用 SQL解析  将SQL放到缓存里 缓存不易过大  算法中要有淘汰机制
 需要有日志记录  bilog
需要有权限划分 
需要容灾机制 数据库挂了如何恢复
支持高并发  需要有索引（优化数据查询） 和锁模块
划分为两大部分 存储部分和实例部分

数据库的开发 和普通程序开发差不多

索引模块 
为什么要使用索引
查询方式   全表扫描 将所有的块和页加载到内存了进行检索  针对表数据比较少的情况

		   索引查询：快速查找数据


什么样的信息能成为索引

主键  唯一键普通键都可以成为索引   索引的数据结构  B+树  还有HASH结构

运用二叉树作为数据结构  对半搜索  时间复杂度是O(logn)
  可能会转变成链表  时间复杂度是O(n)   检索的深度 每增加一就会增加一次IO

将树变矮一些 减少IO操作


优化索引 使用B+树
平衡多路查找树
跟节点至少包含两个孩子
树种每个节点最多包含M个孩子（M>=2)
除根节点和叶子节点外 其他节点至少包含两个孩子ceil（m/2)
所有叶子节点都位于同一层  叶子节点高度是一致的

让每个索引块存储尽可能多的信息


假设每个非中端节点中包含N个关键字信息 其中

B树
Ki(i=1.....n)为关键字，且关键字按顺序升序排列（Ki-1)<Ki
关键字的个数n必须满足[ceil(m/2)-1]<n<m-1
非叶子节点的指针 P[1],P[2],....P[M];其中P[1]指向关键字小于K[1]的子树，
P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于（K[i-1],K[i])的子树

B+树

 非叶子节点的子树指针与关键字个数相同
 非叶子节点的子树指针P[i],指向关键字值K[i],K[i+1] 的子树
 非叶子节点仅仅用来索引，数据都保存在叶子节点中
 所有叶子节点均有一个链指针连接 按照从大到小排序  支持范围统计
 
 
 B+树的磁盘读写代价更低
 因为内部结构 没有指向关键字的指针
 
 B+树的查询效率更加稳定
 
 所有关键字的查询相同
 
 
 B+树更有利于对数据的扫描
 
 
密集索引和稀疏索引的区别

密集索引文件中每个搜索码值都对应一个索引值

一个表只能建立一个密集索引


Mysim
Innodb 
若一个主键被定义，该主键则作为密集索引

若没有主键被定义，改表的第一个唯一非空索引则作为密集索引 

若不满足以上条件，innodb 内部会生成一个隐藏主键（密集索引）
非主键索引存储相关键位和其对应的主键值，包含两次查找


稀疏索引文件置为索引码的某一些值建立索引项



mysim 索引和数据文件是分开的   innodb 数据和索引是再一起的

表结构存储在.frm 文件中


如何定位并优化慢查询SQL

1.根据慢日志定位慢查询sql


2.使用explain等工具分析sql

	explain select * from table 

	type==index  all  表示全表扫描
	extra  
		using filesort 表示MYSQL会对结果使用一个外部索引排序，而不是从表里按照索引次序读到的相关内容
						可能在内存或者磁盘上进行排序。mysql中无法利用索引完成的排序成为文件排序
		using temporary 表示MYSQL对结果查询是用临时表。常见于排序Order by 和分组查询group by
			
3.修改sql尽量让sql走索引

explain 走了哪条索引  查询优化器来做决定 



索引额外问题 之最左匹配原则  

联合索引 多列组成的索引

select  * from table  where a=? and b=? 联合索引


索引是建立的越多越好吗

数据量小的表不需要建立索引 建立索引增加额外开销

数据变更需要维护索引，因此更多的索引意味着更多的维护成本

更多的索引意味着需要很多的空间呢





MyIsam  innodb   锁模块


MyISAM InnoDB 关于锁方面的区别

MyISAM 默认使用的是表级锁 不支持行级锁

InnoDB默认使用的是行级锁 也支持表级锁

什么是行级锁  什么是表级锁

读锁  共享锁 
写锁  排他锁

二段锁   加锁和解锁是分步进行的





数据库事务的四大特性

ACID 
 原子性  一致性 隔离性  持久性
 
 
一致性 假如  A 有1000元 转向B   转前和转后两人的钱加一起还是1000




事务隔离级别以及各级别下的并发访问问题

select @@tx_isolation

set session transaction isolation level read committed

start transaction

commit;

rollback



读未提交 read uncommitted 脏读 不可重复读 幻读

读已提交 read  committed   不可重复读 幻读

可重复读 repeatable read 幻读

序列化 serializable 所有的操作都会加锁 加了  next-key(行锁+gap锁)





InnoDB 可重复读隔离级别下如何避免幻读

当前读和快照读

当前读   select .....lock in share mode select ..... for update
		  update  delete  insert
		  
		  

快照读  不加锁 非阻塞读 ，select 

InnoDB 可重复读隔离级别下如何避免幻读
RR读如何避免幻读
gap锁 






group by   

对查询结果进行分组  select 子句中的列名必须为分组列或列函数

列函数对于group by

count 求总数

sum 求和



hiving   
 通常与group by使用 
 where 过滤行  hiving过滤组
 同一个sql里顺序 where group by  hiving 
 






























